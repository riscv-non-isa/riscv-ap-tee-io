[[theory_operations]]

== Theory of Operations

The CoVE-IO specification extends the CoVE host and guest SBI extensions to
allow TVMs to establish trust with TEE-IO devices, and then use and interact
with those devices. Untrusted supervisor domain components are responsible for
assigning TEE-IO devices to TVMs, and also for supporting the TVM acceptance or
rejection of the assigned devices. The TSM, on the other hand, establishes and
maintains the secure physical and logical links between TVMs and their assigned
devices.

The following sections describe the functionality of the TSM-provided CoVE-IO
extensions to support trusted I/O on CoVE-enabled platforms.

=== Platform Initialization

==== IOMMU Registration and Setup

The TSM relies on the availability of at least one IOMMU instance exclusvely
associated with the TSM supervisor domain. Those IOMMUs allow the TSM to enforce
the integrity of address translations and protection from DMA into confidential
memory, as well as  interrupts originating from assigned TDIs. The host
supervisor domain may assign one or more IOMMU instances to the TSM supervisor
domain, after which, only the TSM can access and program the assigned IOMMU
instances.

IOMMUs assigned to the TSM security domain may generate MSIs in order to signal
the TSM about command completions, transaction faults or device page requests.
Those MSIs target system physical memory, which is owned by the host security
domain manager, e.g. the host VMM. As a consequence, it is the host security
domain's responsibility to reserve the MSI addresses and then rely on the TSM to
program the IOMMUs with those reserved addresses. This IOMMU registration
process is driven by the untrusted domain manager for all IOMMUs that
participate in TEE-IO and operates as described in the following steps:

1. The TSM is loaded into a supervisor domain and provisioned with a CoVE-IO
   manifest. It is recommended that the TSM is measured by the root-of-trust for
   measurement (RTM) for subsequent attestation.
2. The host supervisor domain manager (e.g. the host VMM) enumerates all
   platform IOMMUs as PCIe devices.
3. The host IOMMU driver is loaded and probed.
4. The host IOMMU driver allocates MSI vectors for the trusted domain
   IOMMUs. Those vectors must point to the untrusted IOMMU driver as the TSM can
   not handle external interrupts.
5. The host supervisor domain manager registers the IOMMUs with the TSM by
   calling the `sbi_covh_register_iommu()` `COVH` function. The TSM gets the
   allocated MSI vectors and configures the trusted IOMMU `s_msi_cfg_table`
   register accordingly.
6. When a trusted IOMMU sends an MSI, the untrusted IOMMU driver handles it and
   notifies the TSM about a pending trusted IOMMU MSI by calling the
   `sbi_covh_notify_iommu_msi()` `COVH` function.
7. The TSM verifies that there is a pending MSI by reading the IOMMU `s_ipsr`
   register, and handles the interrupts as needed.

The host IOMMU driver may be malicious and attempt to trick the TSM by either
invoking the `sbi_covh_notify_iommu_msi()` `COVH` function while there are no
pending MSI from the trusted IOMMU or not invoking it when there actually is one
such pending interrupt. In the former case, the TSM can verify that there really
is a pending MSI by checking the trusted IOMMU status registers. The latter case
could cause a denial of service, which is not in scope of the confidential
computing threat model. If the TSM must ensure that a given command is completed
without having to rely on untrusted IOMMU driver MSI notifications, it can queue
an `IOFENCE.C` command after the desired command and check for the `cqh`
advancing past the `IOFENCE.C` command index.

==== PCIe Root Port Registration

When the data link between the TDI and the TVM must be secured, trusted I/O
relies on the PCIe IDE protocol. IDE provides confidentiality and integrity
protection for TLPs received and transmitted between the physical device the TDI
belongs to and its assigned PCIe root port (RP). Both endpoints (The RP and the
physical device) must be configured with the same encryption keys through the
IDE key management protocols and have their IDE PCIe extended capability
configured as well.

As described in the threat model and requirement sections, the following trusted
I/O rules apply:

* As PCIe switches are outside of the TVM TCB, only selective IDE streams are
  used to protect the PCIe link between the TVM and the TDI.
* A single selective IDE stream is established between the physical device and
  its Root Port. All TDIs from the physical device share this single IDE stream.
* For each physical device from which a TDI is attached to a TVM, the TSM
  generates, owns and distributes the IDE stream keys to both the physical
  device and the RP.
* The TSM configures the RP PCIe IDE extended capability.

As the TSM is responsible for setting both the RP IDE keys and PCI IDE
capabilities, it must be the IDE operations owner for any downstream device for
a given RP. As the overall platform resources owner, the host supervisor domain
software stack must register a RP for TEE I/O and IDE ownership with the TSM, by
calling the `sbi_covh_register_rp()` `COVH` function. This function associates a
RP id to its MMIO space (for the IDE capability configurations) and all the MMIO
ranges that are routed through it. The TSM must compare these 2 arguments with
the information it received from the platform ROT through the TEE I/O manifest.
If both match, it can proceed into establishing an SPDM session with the RP.

===== Root-of-Trust SPDM Session

For each TDI that gets attached to a TVM, its corresponding PCIe root port must
be configured with per-device IDE keys. This configuration is done through the
PCIe IDE key management protocol (IDE_KM) that runs on top of an SPDM session.
It is thus necessary to establish an SPDM session with all trusted I/O
registered root ports. This is akin to considering the RP as just another
trusted device for which the DSM is the platform ROT. The SPDM establishment
thus happens between the TSM and the platform ROT. By having the ROT playing the
RP DSM role, the RP vendor-specific IDE key management interface is abstracted
by the ROT.

[[IDE_KM_RPT_OP]]
.PCIe Root Port IDE Key Management through Root-of-Trust
image::images/rp_rot_idekm.svg[align="center"]

=== SPDM Transport

SPDM is the main transport protocol for securely setting both the RP and the
physical device IDE keys and also for driving the TDI through the TDISP state
machine.

[[spdm_message]]
.SPDM Message Layout
image::images/SPDM_session.svg[align="center"]


Whether the SPDM session is established with the ROT or the physical device, the
TSM is the requester and it must reach and communicate with DOE mailboxes that
are owned by the host supervisor domain manager. As a consequence, after
requesting the TSM to establish an SPDM session with a device (through the
`sbi_covh_connect_device()` `COVH` call), it acts as an untrusted SPDM messages
proxy between the TSM and the device DSM.

After a successful call to `sbi_covh_connect_device()`, host supervisor domain
initiated CoVE-IO `COVH` calls that require SPDM requests to be sent to the device
DOE mailbox follows the flow described below:

.SPDM Flow With CoVE
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant Responder as Device or ROT (SPDM Responder)
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM

VMM ->> TSM: [COVH] - sbi_covh_tee_io_action()
TSM ->> TSM: Generate SPDM request REQ_1
TSM ->> VMM: [COVH] - SBI_SUCCESS(SPDM_PENDING_REQUEST REQ_1)
VMM ->> Responder: [DOE] - SPDM_REQ_1
Responder ->> VMM: [DOE] - SPDM_RESP_1
VMM ->> TSM: [COVH] - sbi_covh_tee_io_action(RESP_1)
TSM ->> TSM: Generate SPDM request REQ_2
TSM ->> VMM: [COVH] - SBI_SUCCESS(SPDM_PENDING_REQUEST REQ_2)
VMM ->> Responder: [DOE] - SPDM_REQ_2
Responder ->> VMM: [DOE] - SPDM_RESP_2
VMM ->> TSM: [COVH] - sbi_covh_tee_io_action(RESP_2)
TSM ->> VMM: [COVH] - SBI_ERROR_CODE(SPDM_REQUEST_COMPLETED)
....

The TSM generates the SPDM request to support the initial CoVE-IO `COVH` call and
copies the request into the per-vcpu shared, non-confidential memory region that
the host supervisor domain and the TSM share as per the CoVE specification. The
TSM replies to the host supervisor domain manager request with the `SBI_SUCCESS`
error code and the `SPDM_PENDING_REQUEST (0x1)` value through the `sbiret`
structure. The host supervisor domain manager then sends the pending SPDM
request to the device DOE mailbox. It forwards the device SPDM response to the
TSM, by copying it to the same SPDM buffer it fetches the SPDM request from and
by calling again the same CoVE-IO `COVH` call.
This process continues until the initial CoVE-IO call is completed. The TSM then
replies to the last `COVH` call with the appropriate error code and the
`SPDM_REQUEST_COMPLETED (0x0)` value through the `sbiret` structure.

The TSM only supports one pending SPDM transaction per device, and the CoVE NACL
shared memory holds one pending SPDM action buffer per device the TSM is
connected to. Each pending SPDM action buffer is structured as described in the
following layout:

.Pending SPDM Transaction Buffer Layout
[options="header"]
|===
| Offset (bytes) | Field | Length (bytes) | Description

| `0h`  | `FUNCTION_ID` | 4 | The SBI Function ID this pending SPDM transaction
                              applies to.
| `4h`  | `DEVICE_ID`   | 4 | The PCIe device ID this pending SPDM transaction
                              applies to.
| `8h`  | `SPDM_PAYLOAD_LENGTH` | 4                         | SPDM payload length.
| `12h` | `SPDM_PAYLOAD`        | See `SPDM_PAYLOAD_LENGTH` | SPDM payload data
                                                              (e.g. TDISP, IDE_KM).
|===

In this document, for readability reasons, flow definitions that involve SPDM
based exchanges are simplified and do not include the above described flow
between the TSM, the host supervisor domain manager and the SPDM responder. In
particular, the steps that cover the SPDM request generation from the TSM, the
transmission to the host VMM, the transmission to the SPDM responder and finally
the path back to the TSM are reduced into 2 steps:

1. TSM sends SPDM request #1
2. TSM receives SPDM response #1

For example the above example would be described through those simplified steps:

1. VMM calls `sbi_covh_tee_io_action()`
2. TSM sends SPDM request #1
3. TSM receives SPDM response #1
4. TSM sends SPDM request #2
5. TSM receives SPDM response #2
6. TSM returns `sbi_covh_tee_io_action()`

==== Secure SPDM Session

With trusted I/O, the TSM establishes SPDM sessions with both the ROT and the
physical devices DSMs. As those sessions are used to exchange IDE keys through
the `IDE_KM` protocol while going through the host supervisor domain manager,
they need to be confidentiality and integrity protected. Establishing a secured
SPDM session for IDE key management or TDISP operations between the TSM and
either PCIe root ports or devices is a mandatory requirement for TVMs to accept
TDIs into their TCB.

Any trusted I/O SPDM session is established through the SPDM responder DOE
mailbox, which could be either the ROT acting as a DSM for the PCIe root ports,
or the physical device DSM. In either case the mailboxes are resources owned by
the host security domain manager which thus initiates the SPDM session
establishment. It acts as an untrusted proxy between the TSM and the DSM by
requesting the TSM to generate SPDM requests through the CoVIO `COVH`TH ABI,
sending those requests to the DOE mailbox and forwarding the SPDM responses back
to the TSM, as described in the SPDM flow section.

=== Device Connection

After the IOMMU is registered with the TSM, the host supervisor domain manager
must establish a logical connection with any device from which a TDI could be
bound to a TVM. To do so, it must cooperate with the TSM to properly initialize
all such physical devices.

The device initialization process aims at establishing secured,
integrity-protected control and data planes between the TSM and the
DSM running in either the platform ROT or a physical PCIe device.
The secured control plane is based on the SPDM protocol and is an encrypted,
integrity-protected software session that is used for passing TDISP and IDE_KM
messages between the TSM and the DSM.
The data place is a hardware session based on the PCIe Integrity and Data
Encryption (IDE) specification and is used to secure the PCIe TLPs.

When the host supervisor domain detects a new TEE-IO capable device, it must go
through two device initialization steps:

1. Establish a secured SPDM session between the TSM (The SPDM Requester) and the
   device DSM (The SPDM responder).
2. Set the PCIe IDE stream up for encrypting the PCIe link.

The CoVE-IO `COVH` extension supports those two initialization steps through one
single function: `sbi_covh_connect_device()`.

When the host supervisor domain manager calls `sbi_covh_connect_device()`, it
requests the TSM to establish an SPDM session with a device, and to set an PCIe
IDE link between the device and the TSM.

==== SPDM Session

The first step for initializing a TEE-IO capable device is to establish a
secured SPDM session between the TSM an the device. The secured SPDM sessions
will then be used to carry `TDISP` and `IDE_KM` messages, in order to
respectively secure the physical link between the device and its PCIe root port,
and for binding or unbinding TDIs to or from a TVM.

The host supervisor domain manager requires the TSM to establish a secured SPDM
session with the physical device by calling the `sbi_covh_connect_device()`
COVH function. Before proceeding into actually establishing the session, the TSM
must check that:

1. The physical device is a downstream endpoint of a root port that
   the host supervisor domain manager has previously registered with the TSM.
2. A secured SPDM session between the TSM and the upstream root port is
   established.

The TSM establishes a secured SPDM session with the physical device DSM by going
through the steps described in the Secured SPDM Session section.

.Device Connection - Secured SPDM Session
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant DSM as Device DSM or ROT
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM

VMM ->> TSM: [COVH] - sbi_covh_connect_device(device_id, stream_id)

Note over TSM,DSM: TSM: SPDM Connection Setup

TSM ->> TSM: Generate SPDM request: GET_VERSION
TSM ->> VMM: [COVH] - spdm_req(GET_VERSION)
VMM ->> DSM: [DOE] - SPDM_GET_VERSION
DSM ->> VMM: [DOE] - SPDM_VERSION
VMM ->> TSM: [COVH] - spdm_resp(VERSION)

TSM ->> TSM: Generate SPDM request: GET_CAPABILITIES
TSM ->> VMM: [COVH] - spdm_req(GET_CAPABILITIES)
VMM ->> DSM: [DOE] - SPDM_GET_CAPABILITIES
DSM ->> VMM: [DOE] - CAPABILITIES
VMM ->> TSM: [COVH] - spdm_resp(CAPABILITIES)

TSM ->> TSM: Generate SPDM request: NEGOTIATE_ALGORITHMS
TSM ->> VMM: [COVH] - spdm_req(NEGOTIATE_ALGORITHMS)
VMM ->> DSM: [DOE] - SPDM_NEGOTIATE_ALGORITHMS
DSM ->> VMM: [DOE] - ALGORITHMS
VMM ->> TSM: [COVH] - spdm_resp(ALGORITHMS)

TSM ->> TSM: Generate SPDM request: GET_CERTIFICATE
TSM ->> VMM: [COVH] - spdm_req(GET_CERTIFICATE)
VMM ->> DSM: [DOE] - GET_CERTIFICATE
DSM ->> VMM: [DOE] - CERTIFICATE
VMM ->> TSM: [COVH] - spdm_resp(CERTIFICATE)
TSM ->> TSM: Verify and store device certificate chain

Note over TSM,DSM: TSM: SPDM Key Exchange

TSM ->> TSM: Generate ephemeral SPDM session DHE key pair - DheKey0
TSM ->> TSM: Generate SPDM request: KEY_EXCHANGE(DheKey0Pub)
TSM ->> VMM: [COVH] - spdm_req(KEY_EXCHANGE)
VMM ->> DSM: [DOE] - SPDM_KEY_EXCHANGE
DSM ->> DSM: Generate ephemeral SPDM session DHE key pair - DheKey1
DSM ->> VMM: [DOE] - KEY_EXCHANGE_RSP(DheKey1Pub)
VMM ->> TSM: [COVH] - spdm_resp(KEY_EXCHANGE_RSP)
TSM ->> TSM: Derive DHE secret
TSM ->> TSM: Derive SPDM session handshake secrets
TSM ->> TSM: Generate SPDM request: FINISH
TSM ->> VMM: [COVH] - spdm_req(FINISH)
VMM ->> DSM: [DOE] - SPDM_FINISH
DSM ->> VMM: [DOE] - FINISH_RSP
VMM ->> TSM: [COVH] - spdm_resp(FINISH_RSP)
TSM ->> TSM: Derive SPDM session application secrets

Note over TSM,DSM: TSM: SPDM Session Created

....


==== IDE Link

The SPDM session is a software link between the TSM and the DSM, secured after
both entities go through a DHE key exchange over the untrusted host supervisor
domain manager proxy. SPDM is used as a control link for configuring the rest of
the device and then running the TDI binding flows.

The last part of the device connection process is about securing the data link
between the TSM and the device, and that must be done through the IDE Key
Management protocol.
Here again, the host supervisor domain manager implictly initiates the PCI IDE
link setup by calling the `sbi_covh_connect_device()` `COVH` function, and
relies on the TSM to generate and send IDE KM messages over SPDM.

The TSM is responsible for:

1. Configuring the PCIe root port IDE Extended Capability.
2. Generating the IDE keys for all sub-streams for a given stream ID.
3. Setting the PCIe root port IDE keys for a given stream ID, through IDE KM
   requests.
4. Refreshing the PCIe root port IDE keys for a given stream ID.
5. Generating all IDE KM requests and encapsulating them into SPDM messages.
6. Setting the PCIe device IDE keys through IDE KM requests.

The host supervisor domain manager is responsible for:

1. Generating and managing system wide PCIe stream IDs.
2. Setting the device PCIe device IDE PCI Extended Capability.
3. Programing the PCIe switch between the device and PCIe root port, such as
   IDE Control Register - Flow-Through IDE Stream Enabled.
4. Initiating the IDE link setup.

The IDE link initial setup must go through the following steps:

1. The host supervisor domain manager finds an available stream ID and
   configures the device IDE Extended Capability accordingly.
2. The host supervisor domain manager programs the device IDE extended
   capability: All RIDs and all memory is allowed, IDE is disabled for the
   selected stream.
3. The host supervisor domain manager implicitly initiates the IDE link setup
   by calling the `sbi_covh_connect_device()` `COVH` function, and passing the
   selected stream ID as an argument to it. The TSM must first establish a
   secured SPDM session, as described in the previous section.
4. After it establishes a secured SPDM session with the device, the TSM starts
   setting the IDE link up and programs the Root Port IDE Extended Capability
   with the proper RID range and the stream ID selected by the host supervisor
   domain manager in step 1. IDE is disabled for that stream ID. The capability
   is only accessible to the TSM, i.e. any writes to it with the C-bit set to 0
   are dropped and reads return all 1s.
5. The TSM generates an IDE key for each sub-stream for the stream ID.
6. The TSM, for each Rx and Tx sub-stream (6 of them), programs the generated
   keys into the physical device:
   a. Generates and sends an `IDE_KM KEY_PROG` message to the DSM. The message
      is encapsulated in a vendor-defined SPDM request.
   b. Receives an `IDE_KM_KEY KP_ACK` from the DSM.
7. The TSM, for each Rx and Tx sub-stream (6 of them), programs the generated
   keys into the physical device’s PCIe root port:
   a. Generates and sends an `IDE_KM KEY_PROG` message to the ROT. The message
      is encapsulated into a vendor-defined SPDM request.
   b. Receives an `IDE_KM_KEY KP_ACK` from the ROT.
8. The TSM, for each Rx sub-stream (3 of them), triggers IDE in the physical
   device:
   a. Generates and sends an `IDE_KM SET_GO(Rx)` message to the DSM. The message
      is encapsulated into a vendor-defined SPDM request.
   b. Receives an `IDE_KM_KEY K_GOSTOP_ACK` from the DSM.
9. The TSM, for each Rx sub-stream (3 of them), triggers IDE in the physical
   device’s PCIe root port:
   a. Generates and sends an `IDE_KM SET_GO(Rx)` message to the ROT. The message
      is encapsulated into a vendor-defined SPDM request.
   b. Receives an `IDE_KM_KEY K_GOSTOP_ACK` from the ROT.
10. The TSM, for each Tx sub-stream (3 of them), triggers IDE in the physical
    device:
   a. Generates and sends an `IDE_KM SET_GO(Tx)` message to the DSM. The message
      is encapsulated into a vendor-defined SPDM request.
   b. Receives an `IDE_KM_KEY K_GOSTOP_ACK` from the DSM.
11. The TSM, for each Tx sub-stream (3 of them), triggers IDE in the physical
    device’s PCIe root port:
    a. Generates and sends an `IDE_KM SET_GO(Tx)` message to the ROT. The
        message is encapsulated into a vendor-defined SPDM request.
    b. Receives an `IDE_KM_KEY K_GOSTOP_ACK` from the DSM.

.Device Connection - IDE Link Setup
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant DSM as Device DSM
participant Device as PCIe Device
participant RootPort as PCIe Root Port
participant RoT as RoT (RP DSM)
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM

VMM ->> VMM: Find an available IDE stream ID
VMM ->> Device: Program IDE extended capability (Allow all RIDs and memory, disable IDE).

VMM ->> TSM: [COVH] - sbi_covh_connect_device(device_id, stream_id)

Note over TSM,DSM: TSM: SPDM Connection Initialization

Note over TSM,DSM: TSM: SPDM Connection Created

TSM ->> RoT: Program RP IDE extended capability (Allow RID and memory for the device, IDE is disabled).

TSM ->> TSM: Generate 6 IDE keys [(Rx, Tx) * sub-streams(P, NP, C)]

Loop 6 times - TSM programs IDE keys into Device (For the given stream ID)
     TSM ->> TSM: Generate SPDM request IDE_KM_KEY_PROG
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_KEY_PROG)
     VMM ->> DSM: [DOE] - SPDM_IDE_KM_KEY_PROG
     DSM ->> Device: Program  IDE Key
     DSM ->> VMM: [DOE] - SPDM_IDE_KM_KP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_KP_ACK)
end

Loop 6 times - TSM programs IDE keys into Root Port through RoT (For the given stream ID)
     TSM ->> TSM: Generate SPDM request IDE_KM_KEY_PROG
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_KEY_PROG)
     VMM ->> RoT: [DOE] - SPDM_IDE_KM_KEY_PROG
     RoT ->> RootPort: Program  IDE Key
     RoT ->> VMM: [DOE] - SPDM_IDE_KM_KP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_KP_ACK)
end

Loop 3 times (For each sub-stream)
     TSM ->> TSM: Generate SPDM request IDE_KM_K_SET_GO
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_K_SET_GO)
     VMM ->> DSM: [DOE] - SPDM_IDE_KM_K_SET_GO
     DSM ->> Device: Trigger Tx IDE
     DSM ->> VMM: [DOE] - SPDM_IDE_KM_K_GOSTOP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_K_GOSTOP_ACK)
end

Loop 3 times (For each sub-stream)
     TSM ->> TSM: Generate SPDM request IDE_KM_K_SET_GO
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_K_SET_GO)
     VMM ->> RoT: [DOE] - SPDM_IDE_KM_K_SET_GO
     RoT ->> Device: Trigger Tx IDE
     RoT ->> VMM: [DOE] - SPDM_IDE_KM_K_GOSTOP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_K_GOSTOP_ACK)
end

Loop 3 times (For each sub-stream)
     TSM ->> TSM: Generate SPDM request IDE_KM_K_SET_GO
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_K_SET_GO)
     VMM ->> DSM: [DOE] - SPDM_IDE_KM_K_SET_GO
     DSM ->> Device: Trigger Rx IDE
     DSM ->> VMM: [DOE] - SPDM_IDE_KM_K_GOSTOP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_K_GOSTOP_ACK)
end

Loop 3 times (For each sub-stream)
     TSM ->> TSM: Generate SPDM request IDE_KM_K_SET_GO
     TSM ->> VMM: [COVH] - spdm_req(IDE_KM_K_SET_GO)
     VMM ->> RoT: [DOE] - SPDM_IDE_KM_K_SET_GO
     RoT ->> Device: Trigger Rx IDE
     RoT ->> VMM: [DOE] - SPDM_IDE_KM_K_GOSTOP_ACK
     VMM ->> TSM: [COVH] - spdm_resp(IDE_KM_K_GOSTOP_ACK)
end

TSM ->> VMM: [COVH] - spdm_covh_connect_device()

VMM ->> Device: Enable IDE for the selected stream
VMM ->> RootPort: Enable IDE for the selected stream
....

=== Device Disconnection

=== Interface Binding

Once both the SPDM session and the IDE link are secured and established, the
host supervisor domain manager may bind a TDI and a TVM together, through the
`COVH` interface. This is a four steps process:

1. The host supervisor domain manager initiates the interface binding flow by
   having the TSM move the TDI into the TDISP `CONFIG_LOCKED` state. This is
   achieved through the `sbi_covh_bind_interface()` `COVH` ABI.
2. The TVM xref:_tdi_acceptation[verifies and accepts the locked TDI] into its
   TCB.
3. The TVM asks the TSM to move the TDI to the TDISP `RUN` state, by calling the
   `sbi_covg_start_interface()` `COVG` ABI.
4. The TVM verifies that the TDI is in the TDISP `RUN` state and starts
   using it. This verification is provided by the
   `sbi_covg_get_interface_state()` `COVG` ABI.

The next two sections respectively give a detailed description of the overall
process for binding an interface to a TVM, and one if its most critical steps:
the TVM decision of accepting or rejecting the TDI into its TCB.

==== Binding Flow

Binding an interface and a TVM together goes through the following steps:

1. For the binding process to succeed, the host supervisor domain manager must
   first pass each of the bound TDI MMIO ranges to the TVM. It does so by
   calling the `sbi_covh_add_tvm_interface_region()` `COVH` ABI. The TSM services
   those requests by creating uncacheable G-stage mappings for each range, so
   that the TVM outbound transaction will not trigger MMIO page faults. The TSM
   must not enable the above mappings until the TVM accepts the TDI in its TCB,
   by moving it to the TDISP `RUN` state.
2. The host supervisor domain manager calls the `sbi_covh_bind_interface()`
   `COVH` function to start binding the TDI and the TVM together. The TSM
   rejects that request if a secured SPDM session is not established with the
   DSM or if a stream IDE link is not set up.
3. The TSM discovers and queries the TDI's TDISP version and capabilities by
   respectively generating and sending the TDISP `GET_TDISP_VERSION` and
   `GET_TDISP_CAPABILITIES` messages to the DSM. The respective `TDISP_VERSION`
   and `TDISP_CAPABILITIES` responses let the TSM select a common TDISP version
   and set of capabilities to be used in all future TDISP communication with the
   DSM.
4. The TSM locks the bound TDI by generating and sending a TDISP
   `LOCK_INTERFACE_REQUEST` message to the DSM, which is encapsulated into a
   vendor-defined SPDM request.
5. The TSM receives the TDISP `LOCK_INTERFACE_RESPONSE` message, which contains
   a device-generated nonce. The TSM stores the nonce. The TDI is now in the
   TDISP `CONFIG_LOCKED` state.
6. The TSM programs the DMA mappings into the trusted IOMMU space, in order for
   the TDI inbound transactions to map into the TVM address space. The IOMMU
   mappings are programmed but not validated. They will be validated only once
   the TDI moves to the TDISP `RUN` state, i.e. when it accepts the TDI into
   its TCB through the `sbi_covg_start_interface()` `COVG` ABI.
7. Through regular discovery mechanisms (ACPI, PCI bus scanning), the TVM
   detects the assigned TDI. It is important to note that the TDI configuration
   space, including its BARs, is emulated by the host security domain manager.
   The TDI MMIO ranges are mapped into the TVM address space by the host
   security domain manager, through the `sbi_covh_add_tvm_interface_region()`
   `COVH` ABI.
8. Before using the TDI, the TVM must
   xref:tdi-acceptation[accept it into its TCB]. Moreover, the TVM must not use
   the TDI until it can verify from the TSM that it’s been put in the TDISP
   `RUN` state (step 12 below). To notify the TSM about its decision to accept
   or reject the bound TDI, the TVM respectively call into the
   `sbi_covg_start_interface()` or `sbi_covg_stop_interface()` `COVG` ABI.
9. Upon acceptation of the TDI by the TVM, the TSM generates and sends a TDISP
   `START_INTERFACE_REQUEST` message that includes the `LOCK_INTERFACE_RESPONSE`
   nonce received on step 5. The message is encapsulated into a vendor-defined
   SPDM request.
10. The TSM receives the TDISP `START_INTERFACE_RESPONSE`. The TDI is now in the
    TDISP `RUN` state.
11. The TSM enables the IOMMU and the TVM G-stage mappings configured on steps 6
    and 1, for respectively enabling the DMA and MMIO operations with the bound
    TDI.
12. The TVM verifies that the TDI is in the TDISP `RUN` state by calling the
    `sbi_covg_get_interface_state()` `COVG` ABI.
13. The TVM can start using the device.

.Device Interface Binding - Bind Interface
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant TDI as Device Interface
participant DSM as Device DSM
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM
participant IOMMU

note over TDI: CONFIG_UNLOCKED

loop For all the TDI MMIO regions exposed to the TVM
     VMM ->> TSM: [COVH] sbi_covh_add_tvm_interface_region()
     TSM ->> TSM: Prepare G-stage mappings and mark them invalid
     TSM ->> TSM: Store the interface MMIO gpa -> hpa mapping
     TSM ->> VMM: [COVH] sbi_covh_add_tvm_interface_region()
end


VMM ->> TSM: [COVH] sbi_covh_bind_interface()

TSM ->> TSM: Generate TDISP GET_TDISP_VERSION
TSM ->> VMM: [COVH] spdm_req(GET_TDISP_VERSION)
VMM ->> DSM: [DOE] SPDM_GET_TDISP_VERSION
DSM ->> VMM: [DOE] SPDM_TDISP_VERSION
VMM ->> TSM: [COVH] spdm_resp(TDISP_VERSION)
TSM ->> TSM: Decrypt TDISP_VERSION

TSM ->> TSM: Generate TDISP GET_TDISP_CAPABILITIES
TSM ->> VMM: [COVH] spdm_req(GET_TDISP_CAPABILITIES)
VMM ->> DSM: [DOE] SPDM_GET_TDISP_CAPABILITIES
DSM ->> VMM: [DOE] SPDM_TDISP_CAPABILITIES
VMM ->> TSM: [COVH] spdm_resp(TDISP_CAPABILITIES)
TSM ->> TSM: Decrypt TDISP_CAPABILITIES

TSM ->> TSM: Generate TDISP LOCK_INTERFACE_REQUEST
TSM ->> VMM: [COVH] spdm_req(LOCK_INTERFACE_REQUEST)
VMM ->> DSM: [DOE] SPDM_LOCK_INTERFACE_REQUEST
DSM ->> TDI: LOCK
note over TDI: CONFIG_LOCKED
DSM ->> VMM: [DOE] SPDM_LOCK_INTERFACE_RESPONSE
VMM ->> TSM: [COVH] spdm_resp(LOCK_INTERFACE_RESPONSE)
TSM ->> TSM: Decrypt LOCK_INTERFACE_RESPONSE
TSM ->> TSM: Store LOCK_Nonce
TSM ->> IOMMU: Disable IOMMU translation for devif_id
TSM ->> IOMMU: Configure C-IOMMU mappings to G-stage
TSM ->> VMM: [COVH] sbi_covh_bind_interface()

note over IOMMU,TDI: TVM verifies the device interface
note over IOMMU,TDI: TVM accepts and uses the device interface
....

==== TDI Verification and Acceptation

It is the TVM responsibility to accept or reject the assigned TDI into its
TCB, and to explicitly notify both the TSM and the host supervisor domain
manager about its decision. The TVM should verify the following security
attributes before being able to decide whether or not it can safely accept a TDI
into its TCB:

1. **SPDM session establishment**: A secured SPDM session must be established
   between the TDI’s DSM and the TSM. TVM verifies that attribute from the TSM,
   through the `sbi_covg_get_device_link()` `COVG` ABI.
2. **IDE link**: The PCIe physical link between the Root Port and the physical
   device must be confidentiality and integrity protected through IDE. As for
   the SPDM session, the TVM calls into the `sbi_covg_get_device_link()` `COVG`
   ABI to verify that attribute from the TSM.
3. **TDISP and SPDM configuration**: The TVM must verify that the TDI TDISP
   configuration and the SPDM session attributes comply with its security policy.
   For example, the TVM could check for the allowed device firmware update
   policy by combining the TDI TDISP report `NO_FW_UPDATE` setting with the SPDM
   session measurement freshness capabilities (`MEAS_FRESH_CAP`). It is then the
   TVM choice to accept or reject a TDI depending on the inferred physical
   device firmware update policy. The TDI interface report and the SPDM session
   attributes are provided by respectively the `sbi_covg_get_interface_report()`
   and the `sbi_covg_get_device_spdm_attrs()` `COVG` ABI.
4. **TDI state**: Before accepting a TDI into its TCB, a TVM must verify that
   its configuration is immutable, and in particular that the host can not
   modify it without having all in-flight transactions being discarded. TEE-IO
   capable physical devices follow the TDISP specification and can guarantee
   that immutability state once the TDI has been moved to the TDISP
   `CONFIG_LOCKED` state. The transition from TDISP `CONFIG_UNLOCKED` to
   `CONFIG_LOCKED` is triggered by the host supervisor domain manager through
   the `COVH` ABI. As such, the TVM can query the TSM for the TDI state through
   the `sbi_covg_get_interface_state()` `COVG` ABI. A TVM must not accept a TDI
   if it’s in any other TDISP state than `CONFIG_LOCKED`.
5. **Device trustworthiness**: Verifying that the TDI is in an immutable state
   across a secured SPDM and physical link is mandatory but not sufficient. The
   TVM must also attest to the physical device trustworthiness in order to
   decide if it can accept one of its TDIs into its TCB. A TVM can trust a PCIe
   device by first authentictating it. Once authenticated, the TVM challenges
   the device and then verifies its measurements:
   a. First the TVM must first verify the authenticity of the device by getting
      its certificate chain from the TSM, through the
      `sbi_covg_get_device_certificate()` `COVG` ABI. The TVM should then verify
      the chain against a provisioned and measured trust anchor list.
   b. Once the device certificate authenticity is verified, the TVM must then
      challenge it by having it sign a piece of data, making sure that the
      device actually owns the private key bound to its certificate. This is
      achieved by getting the TDI measurements from the TSM through the
      `sbi_covg_get_device_measurement()` `COVG` ABI. This set of device-signed
      measurements, also knonw as the device attestation evidence, must be
      verified against the TDI certificate acquired in the previous step.
   c. Finally, the TVM should attest to the device configuration trustworthiness
      (code, SVN, state, etc) by verifying the previously fetched device
      attestation evidence. This is typically done through a remote or local
      attestation procedure.
6. **TDI IO ranges**: The TVM will likely interact with and program the TDI
   through a set of memory mapped IO ranges (e.g. a PCI BAR defined memory
   range). However, when discovering the TDI in its address space, the TVM only
   sees guest physical addresses (GPA) for those ranges, as exposed by the
   host supervisor domain manager  PCI emulation. When communicating with the
   TDI, the TVM will use those GPAs and must rely on their corresponding
   translations to host physical addresses (HPA) to be properly set. In
   particular, it must rely on the fact that the TDI MMIO ranges GPAs do not map
   to non-confidential memory that could be otherwise accessed by a host domain
   component. To verify that security attribute, the TVM must retrieve the TDISP
   report for the TDI, through the `sbi_covg_get_interface_report()`. The TDISP
   report, among other things, contains the list of MMIO ranges for the TDI
   sorted by BAR indexes. First, the TVM must verify that the host VMM exposed
   BARs have the same sizes as the TDISP reported ones. To further validate
   those ranges, the TVM must check from the TSM that they’re correctly mapped
   to host physical ranges. Prior to the TVM being able to accept a TDI, the
   host VMM must have requested the TSM to map all the TDI MMIO ranges to TVM
   GPA ranges, through `sbi_covh_add_tvm_interface_region()` `COVH` calls. The
   TVM then verifies from the TSM that a GPA exposed TDI MMIO range will be
   mapped to the TDISP reported range through the TSM managed G-stage page
   tables, by calling into the `sbi_covg_map_interface_mmio()` `COVG` ABI. The
   TVM can accept a TDI only if the TSM confirms the validity of all MMIO range
   mappings, in the TDISP reported order (i.e. BAR #N in the TVM address space
   will be mapped to the TDISP reported MMIO range #N).

Once the TVM has verified the above security attributes, it lets the TSM know
that it is ready to use the TDI, by calling into the
`sbi_covg_start_interface()` `COVG` ABI.

.Device Interface Verification
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant DSM as Device DSM
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM
participant TVM

VMM ->> TSM: [COVH] sbi_covh_run_vcpu()

note over TVM,TSM: Verify Device Link (Secured SPDM and IDE keys)
    TVM ->> TSM: [COVG] sbi_covg_get_device_link()
    TSM ->> TVM: [COVG] sbi_covg_get_device_link()
    TVM ->> TVM: Verify that Secured SPDM and IDE are established

note over TVM,TSM: Verify TDISP and SPDM Configuration
    TVM ->> TSM: [COVG] sbi_covg_get_device_spdm_attrs()
    TSM ->> TVM: [COVG] sbi_covg_get_device_spdm_attrs()
    TVM ->> TSM: [COVG] sbi_covg_get_interface_report()
    TSM ->> TSM: Generate TDISP request GET_DEVICE_INTERFACE_REPORT
    TSM ->> VMM: [COVH] spdm_req(GET_DEVICE_INTERFACE_REPORT)
    VMM ->> DSM: [DOE] SPDM_GET_DEVICE_INTERFACE_REPORT
    DSM ->> VMM: [DOE] SPDM_DEVICE_INTERFACE_REPORT
    VMM ->> TSM: [COVH] spdm_resp(DEVICE_INTERFACE_REPORT)
    TSM ->> TSM: Decrypt DEVICE_INTERFACE_REPORT
    TSM ->> TVM: [COVG] sbi_covg_get_interface_report()
    TVM ->> TVM: Verify that the TDISP and SPDM configuration comply with the TVM policy

note over TVM,TSM: Verify Device Interface State (TDISP CONFIG_LOCKED)
    TVM ->> TSM: [COVG] sbi_covg_get_interface_state()
    TSM ->> TVM: [COVG] sbi_covg_get_interface_state()
    TVM ->> TVM: Check that the interface state is CONFIG_LOCKED

note over TVM,TSM: Verify Device Identity
    TVM ->> TSM: [COVG] sbi_covg_get_device_certificate()
    TSM ->> TVM: [COVG] sbi_covg_get_device_certificate()
    TVM ->> TVM: Verify the returned device certificate chain

note over TVM,DSM: Challenge Device
    TVM ->> TSM: [COVG] sbi_covg_get_device_measurement()
    TSM ->> TSM: Generate SPDM GET_MEASUREMENTS request
    TSM ->> VMM: [COVH] spdm_req(GET_MEASUREMENTS(Nonce))
    VMM ->> DSM: [COVH] SPDM_GET_MEASUREMENTS(Nonce)
    DSM ->> VMM: [DOE] SPDM_MEASUREMENTS(Nonce)
    VMM ->> TSM: [COVH] spdm_resp(MEASUREMENTS)
    TSM ->> TSM: Decrypt SPDM MEASUREMENTS
    TSM ->> TVM: [COVG] sbi_covg_get_device_measurement()
    TVM ->> TVM: Verify the device measurements with cert chain
    TVM ->> TVM: Device attestation (Local or remote)

note over TVM,TSM: Check Device Interface MMIO mappings
    TVM ->> TVM: Re-use previously fetched TDISP interface report
    loop For all TDISP reported MMIO ranges
         TVM ->> TSM: [COVG] sbi_covg_map_interface_mmio(dev_id, gpa, offset_hpa, size)
         TSM ->> TSM: Compare with the VMM donated MMIO regions (sbi_covh_add_tvm_interface_region)
         TSM ->> TSM: Compare with the RP IDE ranges
         TSM ->> TVM: [COVG] sbi_covg_map_interface_mmio()
    end
....

.Device Interface Acceptation
[source,mermaid]
....
%%{init: {'theme': 'neutral', 'themeVariables': {'darkMode': true}, "flowchart" : { "curve" : "basis" } } }%%
sequenceDiagram

autonumber

participant TDI as Device Interface
participant DSM as Device DSM
participant VMM as Host Supervisor Domain Manager (VMM)
participant TSM
participant TVM

note over TDI: CONFIG_LOCKED
note over TVM: Device interface verified

VMM ->> TSM: [COVH] sbi_covh_run_vcpu()

TVM ->> TSM: [COVG] sbi_covg_start_interface()
TSM ->> TSM: Generate TDISP START_INTERFACE_REQ(LOCK_Nonce)
TSM ->> VMM: [COVH] spdm_req(START_INTERFACE_REQ)
VMM ->> DSM: [DOE] SPDM_START_INTERFACE_REQ
DSM ->> TDI: START
note over TDI: RUN
DSM ->> VMM: [DOE] SPDM_START_INTERFACE_RESP
VMM ->> TSM: [COVH] spdm_resp(START_INTERFACE_RESP)
TSM ->> TSM: Decrypt START_INTERFACE_RESP
TSM ->> TSM: Store device state
TSM ->> TSM: Enable IOMMU translation for devif_id
TSM ->> TSM: Enable G-stage MMIO mappings
TSM ->> TVM: [COVG] sbi_covg_start_interface()
TVM ->> TSM: [COVG] sbi_covg_get_interface_state()
TSM ->> TVM: [COVG] sbi_covg_get_interface_state()
TVM ->> TVM: Check that the interface state is RUN
TVM ->> TVM: Use device interface
....

=== Interface Unbinding

=== Device and Interface Lifecycle

When combined together, the flows and ABIs described in the previous sections
are used to build the lifecycle of a TDISP capable device on a CoVE-IO
compatible platform, as illustrated in the follwing figure:

[[COVE_IO_LIFECYCLE]]
.Device and Interface Lifecycle
image::images/cove-io-lifecycle.svg[align="center"]

The host supervisor domain manager owns the physical device, and manages its
lifecycle. The TSM enforces that this lifecycle management is done without
compromising any TVM confidential assets.

As the platform resources owner, the host supervisor domain manager can assign
a TDI to a TVM by binding them together (step 3). At any point in time, it can
reclaim that physical resource by unbinding (step 8a) it from its TVM.

Before binding a TDI and a TVM together, the host supervisor domain manager must
first require the TSM to connect (step 1) to the physical device through secured
SPDM. As part of servicing that request, the TSM also protects the physical link
with PCIe IDE.

The host supervisor domain manager is also required to explictly add the TDI
MMIO regions to the TDI (step 2). The TSM can prepare and allocate the TVM
second stage page tables and map those I/O regions into the guest physical
address space. The TSM does not enable those tables until the TVM starts the
interface (step 6)

Only once the TSM is securily connected to the physical device, The host
supervisor domain manager can proceed with binding a device interface and a TVM
together. Once bound to a TVM, the device interface is locked but the MMIO and
DMA paths between the two are not enabled yet.

The TVM to which a TDI is bound to is the I/O gatekeeper. After detecting and
verifying (steps 4 and 5) the bound interface, it may accept it into its TCB and
enable all I/O paths between the two parties. The TVM may only use a bound TDI
(step 7) after accepting it, by requesting the TSM to start the device interface
(step 6).

Both the host supervisor domain manager and the TVM can disable I/O between the
TDI and the TVM, by respectively unbinding (step 8a) or stopping the device
interface (step 8b). The host supervisor domain manager may first remove the TDI
MMIO regions from the TVM address space (step 9).

Finally, the host supervisor domain manager can fully reclaim the physical
device by requesting the TSM to disconnect (step 10) from it.
